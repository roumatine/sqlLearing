# SQL优化
· 插入数据
1. insert优化
1) 批量插入数据(500-1k)
insert into tb_test value (1,'tom'),(2,'jack'),(3,'jane')
2) 手动提交事务
start transaction;
insert into tb_test value (1,'tom'),(2,'jack'),(3,'jane');
insert into tb_test value (4,'tom'),(5,'jack'),(6,'jane');
insert into tb_test value (7,'tom'),(8,'jack'),(9,'jane');
commit;
3) 主键顺序插入
主键乱序插入: 8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入: 1 2 3 4 5 7 8 9 15 21 88 89
顺序插入性能高于乱序插入
4) 大批量插入数据
如果一次性需要插入大批量数据使用Insert插入性能较低，可以使用MySQL的LOAD指令进行插入。

· 主键优化
1) 数据组织方式
在innodb中表数据都是根据主键顺序组织春芳的，这种存储方式称为索引组织表
![save](/step2/pic/save_jiegou.jpg)

2) 页(page)分裂
页可以为空也可以填充一半也可以100%。每个夜包含了2-N行数据,(如果一行数据勾搭会行溢出),根据初见排列

3) 页合并
当删除一行记录时，实际上记录没有被物理删除，只是记录被标记(flaged)为删除并且他的空间允许被其他记录声明使用。
当页纸删除的记录达到MERGE_THRESHOLD(默认为页的50%)，InnoDB会开始寻找最靠近的页(前或后)扣款是否可以将两个页合并成优化空间使用。
MERGE_THRESHOLD:合并页的法治，可以自己设置，在创建表或索引时候确定

4) 主键涉及原则
满足业务需求的情况下尽量降低主键的长度
插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键
尽量不要使用UUID左主键或是其他自然主键，如身份证号等。
业务操作时，避免对主键的修改

· order by优化
using filesort:通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序豆角FileSort排序。
using index:通过有序索引扫描直接返回有序数据，不需要额外排序，操作效率很高。

根据排序字段建立合理的索引，多字段排序时也遵循最左前缀法则
尽量使用覆盖索引
多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)
如果不可比曼的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)

· group by优化
在分组操作时，可以通过索引来提高效率
在分组操作时，索引的使用也要满足最左前缀法则

· limit优化
常见问题是limit 2000000,10。此时需要MySQL排序前2000010记录，仅仅返回2000000-2000010的记录，其他记录丢弃，排序查询的代价非常大。
优化思路: 一般分页查询时，通过创建 覆盖索引能够比较好的提高性能，可以通过覆盖索引+子查询方法进行优化

· count优化
explain select count(*) from t_user;
MyISAM引擎会把一个表的总行数存储在磁盘上，因此执行count(*)的时候回直接返这个数，效率很高；
InnoDB引擎就很麻烦，执行count(*)时需要把数据一行一行地从引擎里读出来，然后进行累积计数；
优化思路:自己计数

count的用法
介绍：count()是一个聚合函数，对于返回的结果集，一行行地进行判断，如果count函数的参数不是NULL，累计值就+1，否则不加，最后返回累计值。

用法: count(*):InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加
count(主键): InnoDB引擎会遍历整张表，把每一行的主键id值都取出来返回给服务层。服务层拿到主键后，直接按行进行行累加(主键不可能为NULL)
count(字段):
没有not null 约束，InnoDB会遍历整张表把每一行的自动值都取出来，返回给服务层，服务层判断是否为NULL，不为NULL,技术累加
有not null 约束，InnoDB会遍历整张表把每一行的自动值都取出来，返回给服务层，直接进行累加
count(1): InnoDB引擎会遍历整张表，但不取值。服务层对于返回的每一行，没放一个数字"1"进去，直接按行进行累加。

按效率跑许的话, count(字段) < count(主键) < count(1) ~= count(*), 所以使用count时尽量使用count(*)

· update优化
<!-- 更新数据要根据索引进行更新。否则行锁会升级表锁 -->
InnoDB的行所是针对索引加的索，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。